{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e64a8997_5576d702",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1017751
      },
      "writtenOn": "2021-01-05T09:01:46Z",
      "side": 1,
      "message": "Even degree-1 node need some add-drop function for mux/demuxing or power equalization of channels. the ROADM function also handles this with per channel power target on the egress (ROADM is not only about switching wavelengths). The only case where there would be a transceiver directly connected to a fiber span is for a single channel transmission (not WDM), which is a bit out of the scope in my opinion. So I am not really convinced that this changes is useful (is this a requests from some users ? if so would it be possible to elaborate a bit more why not having a mux function after the transceiver?), but I have no strong opinion against it either.",
      "revId": "7e8ed590eb483720a586356a02eca9196f558201",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62a95255_07a2c6bf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1017862
      },
      "writtenOn": "2021-01-05T13:28:35Z",
      "side": 1,
      "message": "Esther, I agree with you in principle. I implemented this change because I saw program crashes on gnpy.app that could only be explained by users mixing transceivers directly connected to a fiber span and transceivers connected through a Roadm in the same topology. Maybe this is not something they really need - it could be that they just start from the default edfa_example_network.json which does not include any Roadm. But in any case it\u0027s bad to have the program crash. In my opinion we should either allow this or we should change the default example and always enforce connecting transceivers through Roadms (raising an error explaining the problem to the user otherwise).",
      "parentUuid": "e64a8997_5576d702",
      "revId": "7e8ed590eb483720a586356a02eca9196f558201",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "319e48cb_32830742",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1017751
      },
      "writtenOn": "2021-01-05T16:41:49Z",
      "side": 1,
      "message": "This is a good point. I agree that the program should not crash with these cases. This feedback of user experience on the gnpy.app is very interesting !",
      "parentUuid": "62a95255_07a2c6bf",
      "revId": "7e8ed590eb483720a586356a02eca9196f558201",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96842237_83e46f1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1009907
      },
      "writtenOn": "2021-01-01T18:40:59Z",
      "side": 1,
      "message": "I like the description of the problem, and it seems to me that this is a good fix. On the other hand, I think that the simulation will produce an incorrect result because propagate() will still add the full add_drop_osnr which comprises both ADD\u0027s and DROP\u0027s impairments, not just the DROP contribution. \n\nThat might not be a big problem, the code currently does not check that there\u0027s a ROADM at the destination TRX (I haven\u0027t checked, but I think it does not). Perhaps we can ignore that?\n\nEither way, I\u0027ll be interested in Esther\u0027s opinion.",
      "revId": "7e8ed590eb483720a586356a02eca9196f558201",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3c0d45a_a94953eb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1017862
      },
      "writtenOn": "2021-01-01T21:05:09Z",
      "side": 1,
      "message": "\u003e I think that the simulation will produce an incorrect result because propagate() will still add the full add_drop_osnr\nThis is a good point. But I don\u0027t think the problem is much worse than adding the same add_drop_osnr regardless of what type of ROADM architecture is used for adding/dropping (in some architectures there are no amps in the add/drop path of the ROADM). Longer term I think we should come up with a better way to handle add/drop OSNR.",
      "parentUuid": "96842237_83e46f1b",
      "revId": "7e8ed590eb483720a586356a02eca9196f558201",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}