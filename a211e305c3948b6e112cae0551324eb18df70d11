{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "afa518dd_999b207b",
        "filename": "gnpy/core/elements.py",
        "patchSetId": 1
      },
      "lineNbr": 813,
      "author": {
        "id": 1009907
      },
      "writtenOn": "2021-04-22T11:56:07Z",
      "side": 1,
      "message": "This parameter is initialized via interpol_params() which gets invoked via propagate(), and that only has access to the currently propagated channels. Shouldn\u0027t the call be something like this instead?\n \np \u003d polyfit((self.params.f_min, self.params.f_max), self.interpol_dgt, 1)",
      "range": {
        "startLine": 813,
        "startChar": 20,
        "endLine": 813,
        "endChar": 37
      },
      "revId": "a211e305c3948b6e112cae0551324eb18df70d11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a7e5281_27c39ff0",
        "filename": "gnpy/core/elements.py",
        "patchSetId": 1
      },
      "lineNbr": 813,
      "author": {
        "id": 1017862
      },
      "writtenOn": "2021-04-22T13:02:50Z",
      "side": 1,
      "message": "No, I don\u0027t think that would work since self.interpol_dgt is itself interpolated on self.channel_freq. It could be replaced with:\n\np \u003d polyfit(amplifier_freq, self.params.dgt, 1)\n\nwhere amplifier_freq is calculated as in interpol_params():\n\namplifier_freq \u003d arrange_frequencies(len(self.params.dgt), self.params.f_min, self.params.f_max)\n\nThis would always take the whole dgt curve into account. I did think about this but I thought the current approach, which only takes dgt values at the propagated channel frequencies into account, makes sense since the resulting tilt will be more accurate when propagated channels only occupy a small part of the total amplifier bandwidth. I am, however, open to any argument for why the alternative approach would be better. It would also be interesting to hear from system vendors how the tilt is actually controlled in practice.",
      "parentUuid": "afa518dd_999b207b",
      "range": {
        "startLine": 813,
        "startChar": 20,
        "endLine": 813,
        "endChar": 37
      },
      "revId": "a211e305c3948b6e112cae0551324eb18df70d11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4511cfcc_8466e3bc",
        "filename": "gnpy/core/elements.py",
        "patchSetId": 1
      },
      "lineNbr": 813,
      "author": {
        "id": 1009907
      },
      "writtenOn": "2021-04-22T14:07:53Z",
      "side": 1,
      "message": "Right, I missed the fact that \"interpol_dgt\" is already interpolated for the list currently propagated channels; the \"interpol\" in the name was apparently not a clear hint to me :). This means that this patch not only fixes a bug which was present when the range of channels was \"too narrow\", but it is also now made ready for non-uniform channel spacing of the propagated channel. I missed that, and I like the outcome.\n\nHowever, I think the other behavior that you discussed (always taking the amp\u0027s full DGT profile from the equipment library) is \"better\". The measurements from the equipment library were -- I hope -- taken on a full channel load (or at least over a subset of channels while representing the full spectrum equally well). I\u0027m not sure if taking a small subset of that under a completely different scenario is more accurate. Please take my opinion with a huge grain of salt, I won\u0027t pretend I understand the physics behind this.\n\nEither way, it looks like this code would benefit greatly from an explanation what it is doing. You are hoping to achieve a more accurate result here by only considering \"the relevant part\" of the spectral window, so it would be awesome to add a comment which points that out.",
      "parentUuid": "9a7e5281_27c39ff0",
      "range": {
        "startLine": 813,
        "startChar": 20,
        "endLine": 813,
        "endChar": 37
      },
      "revId": "a211e305c3948b6e112cae0551324eb18df70d11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3de061af_3e9c1643",
        "filename": "gnpy/core/elements.py",
        "patchSetId": 1
      },
      "lineNbr": 813,
      "author": {
        "id": 1017862
      },
      "writtenOn": "2021-04-22T14:29:15Z",
      "side": 1,
      "message": "\u003eYou are hoping to achieve a more accurate result here by only considering \"the relevant part\" of the spectral window, so it would be awesome to add a comment which points that out.\n\nIt\u0027s not really that _I_ am hoping. This is what the original code did and I thought it made some sense. The alternative approach I described would be a larger change compared to existing behaviour. Anyway, the real question is what approach best models how a real amplifier behaves. Until we know that, I think we can merge the patch as is since it\u0027s closer to the current implementation.",
      "parentUuid": "4511cfcc_8466e3bc",
      "range": {
        "startLine": 813,
        "startChar": 20,
        "endLine": 813,
        "endChar": 37
      },
      "revId": "a211e305c3948b6e112cae0551324eb18df70d11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7a92987_d959396f",
        "filename": "gnpy/core/elements.py",
        "patchSetId": 1
      },
      "lineNbr": 822,
      "author": {
        "id": 1009907
      },
      "writtenOn": "2021-04-22T11:56:07Z",
      "side": 1,
      "message": "I like this more python approach.",
      "revId": "a211e305c3948b6e112cae0551324eb18df70d11",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}